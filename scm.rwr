scm {
  Main [Item+] = ‛«Item»’
  Item_function [lb _def lb2 functionname args* rb2 body rb] = ‛\n❲def❳ «functionname» («args»):⤷\n«body»⤶\n’
  Item_var [lb _def name body rb] = ‛\n«name» = «body»’
  Item_comment [x] = ‛«x»’
  Item_number [x] = ‛«x»’
  Item_string [x] = ‛«x»’
  Item_toplevel [x] = ‛«x»’

  List [lb xs+ rb] = ‛«lb»«xs»«rb»’
  ListOrAtom_cond [lb _cond ifthenclause+ elseclause? rb] = ‛ if False:⤷\npass⤶«ifthenclause»«elseclause»’
  ListOrAtom_nullp [lb _null arg rb] = ‛ isinstance(«arg», list) ’
  ListOrAtom_stringeq [lb _stringeq arg1 arg2 rb] = ‛ («arg1» == «arg2») ’
  ListOrAtom_let [lb _let lb2 letbinding+ rb2 body rb] = ‛«letbinding»\n«body»’
  ListOrAtom_pair [lb _pair arg rb] = ‛ isintance («arg», list) ’
  ListOrAtom_anonfuncall [lb anon arg* rb] = ‛ «anon» («arg») ’
  ListOrAtom_funcall [lb name arg* rb] = ‛ «name» («arg») ’
  ListOrAtom_lvar [lb _q e rb] =  ‛ lvar («e») ’
  ListOrAtom_quote [lb _quote contents+ rb] = ‛«contents»’
  ListOrAtom_list [x] = ‛«x»’
  ListOrAtom_number [x] = ‛«x»’
  ListOrAtom_string [x] = ‛«x»’
  ListOrAtom_atom [x] = ‛«x»’
  Atom [lb uptorb] = ‛«lb»«uptorb»’
  bracket [c] = ‛«c»’
  sq [c] = ‛«c»’

  Question [q] = ‛«q»’
  LetBinding [lb atom val rb] = ‛\n«atom» = «val»’
  Expr [listOrAtom] = ‛«listOrAtom»’
  Body [re] = ‛«re»’
  ReturningExpr [e] = ‛«e»’
  
  sym [lb s rb] = ‛«lb»«s»«rb»’
  comment [lb uptorb] = ‛«lb»«uptorb»’
  number [ds+] = ‛«ds»’
  string [dq uptodq] = ‛«dq»«uptodq»’
  bq [c] = ‛«c»’
  eq [c] = ‛«c»’
  upto [cs* right] = ‛«cs»«right»’

  FunctionName [n] = ‛«n»’
  Param [n] = ‛«n», ’

  IfThenClause [lb test e rb] = ‛\nelif «test»:⤷\n«e»⤶’
  ElseClause [lb _else e rb] = ‛\nelse:⤷\n«e»⤶’

  QuotedContents_nil [lb rb] = ‛[],’
  QuotedContents_list [lb contents+ rb] = ‛[«contents»],’
  QuotedContents_number [n] = ‛«n»,’
  QuotedContents_string [s] = ‛«s»,’
  QuotedContents_atom [a] =  ‛"«a»",’

}
